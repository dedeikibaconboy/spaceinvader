# Space Blasters — Modern Space Invaders

Saya sudah membuat proyek game sederhana bergaya *Space Invaders* modern. File disusun terpisah agar mudah dipakai: `index.html`, `styles.css`, dan `game.js`.

> Cara pakai singkat:
>
> 1. Buat folder baru.
> 2. Simpan masing‑masing blok kode di bawah ke file dengan nama yang sama (`index.html`, `styles.css`, `game.js`).
> 3. Buka `index.html` di browser (desktop atau HP). Untuk pengalaman terbaik gunakan browser modern.

---

## index.html

```html
<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Space Blasters</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
</head>
<body>
  <main id="app">
    <header class="hud">
      <div class="title">Space Blasters</div>
      <div class="meta">
        <span id="score">Score: 0</span>
        <span id="lives">Lives: 3</span>
      </div>
    </header>

    <div class="game-wrap">
      <canvas id="gameCanvas"></canvas>

      <!-- Mobile controls -->
      <div id="mobileControls" class="mobile-controls" aria-hidden="true">
        <button id="leftBtn" class="ctl">◀</button>
        <button id="fireBtn" class="ctl fire">●</button>
        <button id="rightBtn" class="ctl">▶</button>
      </div>
    </div>

    <footer class="footer">
      <button id="startBtn" class="btn">Start / Restart</button>
      <div class="hint">Use ← → and Space (desktop) or controls below (mobile)</div>
    </footer>
  </main>

  <script type="module" src="game.js"></script>
</body>
</html>
```

---

## styles.css

```css
:root{
  --bg1: #0f1724; /* dark navy */
  --bg2: #071025; /* deeper */
  --accent: #7ee7f7; /* cyan */
  --accent-2: #9b7cff; /* purple */
  --muted: #9aa6b2;
  --glass: rgba(255,255,255,0.04);
}

*{box-sizing:border-box}
html,body,#app{height:100%;}
body{
  margin:0; font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
  background: radial-gradient(1200px 600px at 10% 10%, rgba(158,122,255,0.08), transparent),
              linear-gradient(180deg,var(--bg1),var(--bg2));
  color: #e6eef6; -webkit-font-smoothing:antialiased;
  display:flex; align-items:center; justify-content:center; padding:20px;
}

main#app{width:100%; max-width:1100px;}
.hud{display:flex; justify-content:space-between; align-items:center; margin-bottom:10px}
.hud .title{font-weight:800; letter-spacing:1px; font-size:1.3rem}
.hud .meta{color:var(--muted); font-size:0.95rem}

.game-wrap{position:relative; background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); border-radius:14px; padding:12px; box-shadow:0 10px 30px rgba(2,6,23,0.6);}

#gameCanvas{display:block; width:100%; height:calc(100vw * 0.55); max-height:720px; border-radius:8px; background: linear-gradient(180deg,#021028 0%, #00121a 100%);}

/* Footer */
.footer{display:flex; justify-content:space-between; align-items:center; margin-top:10px}
.btn{background:linear-gradient(90deg,var(--accent),var(--accent-2)); border:none; color:#021026; font-weight:700; padding:10px 16px; border-radius:12px; cursor:pointer}
.hint{color:var(--muted); font-size:0.9rem}

/* Mobile controls */
.mobile-controls{position:absolute; left:50%; transform:translateX(-50%); bottom:18px; display:flex; gap:12px;}
.ctl{width:56px; height:56px; border-radius:12px; border:none; background:var(--glass); color:var(--accent); font-size:1.2rem; backdrop-filter: blur(6px); box-shadow:0 6px 18px rgba(9,12,20,0.6);}
.ctl.fire{width:64px; height:64px; background:linear-gradient(180deg,var(--accent),var(--accent-2)); color:#021026; font-weight:800}

/* Responsive tweaks */
@media (max-width:600px){
  #gameCanvas{height:calc(100vw * 0.85)}
  .hud .title{font-size:1.1rem}
  .ctl{width:48px;height:48px}
  .ctl.fire{width:56px;height:56px}
}
```

---

## game.js

```javascript
// Modern Space Invaders - ES module
// Save as game.js and referenced by index.html

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let DPR = Math.max(1, window.devicePixelRatio || 1);

// UI elements
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const startBtn = document.getElementById('startBtn');
const mobileControls = document.getElementById('mobileControls');
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const fireBtn = document.getElementById('fireBtn');

// Game constants
const CONFIG = {
  playerSpeed: 320,
  bulletSpeed: 700,
  invaderCols: 8,
  invaderRows: 4,
  invaderPadding: 18,
  invaderSpeedBase: 40,
  canvasRatio: 16/9
};

let keys = {};
let game = null;

function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height = Math.floor(rect.width / CONFIG.canvasRatio * DPR);
}

window.addEventListener('resize', () => { DPR = Math.max(1, window.devicePixelRatio || 1); resizeCanvas(); if(game) game.onResize(); });

class Entity{
  constructor(x,y,w,h){ this.x=x; this.y=y; this.w=w; this.h=h; }
  drawRect(fill){ ctx.fillStyle = fill; ctx.fillRect(this.x, this.y, this.w, this.h); }
  collides(other){ return !(this.x+this.w < other.x || this.x > other.x+other.w || this.y+this.h < other.y || this.y > other.y+other.h); }
}

class Player extends Entity{
  constructor(x,y,w,h){ super(x,y,w,h); this.speed = CONFIG.playerSpeed; this.cooldown=0; }
  update(dt,inputWidth){
    if(keys['ArrowLeft']||keys['a']||keys['A']||keys['touchLeft']) this.x -= this.speed*dt;
    if(keys['ArrowRight']||keys['d']||keys['D']||keys['touchRight']) this.x += this.speed*dt;
    this.x = Math.max(8, Math.min(canvas.width/ DPR - this.w - 8, this.x));
    if((keys[' ']||keys['Space']||keys['mouse']||keys['touchFire']) && this.cooldown<=0){ this.cooldown=0.25; return true; }
    this.cooldown = Math.max(0, this.cooldown-dt);
    return false;
  }
  draw(){
    // modern triangular ship
    ctx.save();
    ctx.translate(this.x+this.w/2, this.y+this.h/2);
    ctx.beginPath(); ctx.moveTo(0,-this.h/2); ctx.lineTo(this.w/2, this.h/2); ctx.lineTo(-this.w/2, this.h/2); ctx.closePath();
    const g = ctx.createLinearGradient(this.x, this.y, this.x+this.w, this.y+this.h);
    g.addColorStop(0,'#9b7cff'); g.addColorStop(1,'#7ee7f7');
    ctx.fillStyle = g; ctx.fill();
    ctx.restore();
  }
}

class Bullet extends Entity{ constructor(x,y,vy){ super(x-3,y,6,12); this.vy=vy; } update(dt){ this.y += this.vy*dt; } draw(){ ctx.fillStyle = '#7ee7f7'; ctx.fillRect(this.x, this.y, this.w, this.h); } }

class Invader extends Entity{ constructor(x,y,w,h,kind){ super(x,y,w,h); this.kind=kind; this.alive=true; } draw(t){ if(!this.alive) return; ctx.save(); ctx.translate(this.x, this.y);
    ctx.fillStyle = this.kind%2? '#e2b8ff' : '#7ee7f7';
    // stylized invader pixel-ish
    ctx.fillRect(0,0,this.w,this.h);
    ctx.restore(); }
}

class Game{
  constructor(){ this.reset(); }
  reset(){
    this.score = 0; this.lives = 3; this.time=0; this.paused=false;
    this.particles = [];
    this.player = new Player( (canvas.width/DPR)/2 - 22, (canvas.height/DPR) - 70, 44, 28 );
    this.bullets = [];
    this.invaders = [];
    this.invaderDir = 1; this.invaderOffsetX=0; this.invaderStepTime=0;
    this.spawnInvaders(); this.updateUI();
  }
  spawnInvaders(){
    const cols = CONFIG.invaderCols; const rows = CONFIG.invaderRows;
    const totalW = (cols*32) + (cols-1)*CONFIG.invaderPadding;
    const startX = ((canvas.width/DPR) - totalW)/2 + 8;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = startX + c*(32+CONFIG.invaderPadding);
        const y = 60 + r*(28+CONFIG.invaderPadding);
        this.invaders.push(new Invader(x,y,32,24, (r+c)%2 ));
      }
    }
  }
  onResize(){ /* keep player inside */ this.player.x = Math.min(this.player.x, (canvas.width/DPR)-this.player.w-8); }
  updateUI(){ scoreEl.textContent = `Score: ${this.score}`; livesEl.textContent = `Lives: ${this.lives}`; }
  update(dt){ if(this.paused) return; this.time+=dt;
    // player
    const fired = this.player.update(dt);
    if(fired) this.bullets.push(new Bullet(this.player.x + this.player.w/2, this.player.y - 12, -CONFIG.bulletSpeed));

    // bullets
    for(const b of this.bullets) b.update(dt);
    this.bullets = this.bullets.filter(b => b.y > -50 && b.y < canvas.height/DPR+50);

    // invader movement
    const aliveCount = this.invaders.filter(i=>i.alive).length;
    const speed = CONFIG.invaderSpeedBase + ( (CONFIG.invaderCols*CONFIG.invaderRows - aliveCount) * 6 );
    this.invaderStepTime += dt;
    if(this.invaderStepTime > 0.5 - Math.min(0.35, aliveCount/200)){
      // horizontal step
      let hitEdge = false;
      for(const inv of this.invaders){ if(!inv.alive) continue; inv.x += this.invaderDir * speed * this.invaderStepTime; if(inv.x < 6 || inv.x + inv.w > (canvas.width/DPR)-6) hitEdge = true; }
      if(hitEdge){ this.invaderDir *= -1; for(const inv of this.invaders){ if(!inv.alive) continue; inv.y += 18; } }
      this.invaderStepTime = 0;
    }

    // collisions
    for(const b of this.bullets){ for(const inv of this.invaders){ if(inv.alive && inv.collides(b)){ inv.alive=false; b.y = -999; this.score += 100; this.spawnParticles(inv.x+inv.w/2, inv.y+inv.h/2); } } }

    // invaders reach bottom
    for(const inv of this.invaders){ if(inv.alive && inv.y + inv.h > this.player.y){ this.lives -= 1; this.updateUI(); this.flashScreen(); this.reset(); return; } }

    // update particles
    this.particles.forEach(p => { p.x += p.vx*dt; p.y += p.vy*dt; p.life -= dt; });
    this.particles = this.particles.filter(p=>p.life>0);

    // check win
    if(this.invaders.every(i=>!i.alive)){
      this.score += 1000; this.updateUI(); this.reset();
    }

    this.updateUI();
  }
  spawnParticles(x,y){ for(let i=0;i<18;i++){ this.particles.push({x,y,vx:(Math.random()-0.5)*200, vy:(Math.random()-0.7)*200, life:0.6+Math.random()*0.6}); } }
  flashScreen(){ /* small flash effect: push white overlay briefly */ this.flash=0.6; }
  draw(){
    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save(); ctx.scale(DPR,DPR);

    // starfield background
    this.drawBackground();

    // invaders
    for(const inv of this.invaders) inv.draw(this.time);

    // bullets
    for(const b of this.bullets) b.draw();

    // player
    this.player.draw();

    // particles
    for(const p of this.particles){ ctx.globalAlpha = Math.max(0, p.life); ctx.fillStyle = '#ffd6f7'; ctx.fillRect(p.x-2, p.y-2, 4,4); }
    ctx.globalAlpha = 1;

    // overlay flash
    if(this.flash>0){ ctx.fillStyle = `rgba(255,255,255,${Math.min(0.25,this.flash)})`; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR); this.flash -= 0.03; }

    ctx.restore();
  }
  drawBackground(){ const w = canvas.width/DPR, h = canvas.height/DPR; for(let i=0;i<60;i++){ const x = (i*37 + (this.time*10*(i%3)))%w; const y = (i*73 + ((i%5)*20))%h; ctx.fillStyle = 'rgba(255,255,255,0.02)'; ctx.fillRect(x,y,1.6,1.6); } }
}

// Main loop
let last = performance.now();
function loop(t){ const now = t || performance.now(); const dt = Math.min(0.05, (now - last)/1000); last = now; if(game){ game.update(dt); game.draw(); }
  requestAnimationFrame(loop);
}

// Input handling
window.addEventListener('keydown', e=>{ keys[e.key]=true; if(e.key===' '){ keys['Space']=true; } });
window.addEventListener('keyup', e=>{ keys[e.key]=false; if(e.key===' '){ keys['Space']=false; } });
window.addEventListener('blur', ()=>{ keys = {}; });

canvas.addEventListener('pointerdown', (e)=>{ keys['mouse']=true; });
canvas.addEventListener('pointerup', (e)=>{ keys['mouse']=false; });

// Mobile control buttons
leftBtn.addEventListener('pointerdown', ()=>{ keys['touchLeft']=true; }); leftBtn.addEventListener('pointerup', ()=>{ keys['touchLeft']=false; }); leftBtn.addEventListener('pointercancel', ()=>{ keys['touchLeft']=false; });
rightBtn.addEventListener('pointerdown', ()=>{ keys['touchRight']=true; }); rightBtn.addEventListener('pointerup', ()=>{ keys['touchRight']=false; }); rightBtn.addEventListener('pointercancel', ()=>{ keys['touchRight']=false; });
fireBtn.addEventListener('pointerdown', ()=>{ keys['touchFire']=true; setTimeout(()=>keys['touchFire']=false,120); });

startBtn.addEventListener('click', ()=>{ game.reset(); });

// Detect mobile and show controls
function detectMobile(){ const isMobile = /Mobi|Android|iPhone|iPad|Phone/.test(navigator.userAgent);
  mobileControls.style.display = isMobile ? 'flex' : 'none'; }

detectMobile();

// init
function init(){ resizeCanvas(); game = new Game(); last = performance.now(); requestAnimationFrame(loop); }

init();
```

---

Jika ingin ditingkatkan lagi (musik, nivo level, power-up, leaderboard lokal, file ZIP untuk didownload, atau versi React/TypeScript) katakan saja — saya akan tambahkan.

Selamat! Buka `index.html` di browser untuk mencoba game. Jika mau, saya bisa bungkus jadi file ZIP atau jelaskan cara deploy ke hosting gratis (GitHub Pages).
